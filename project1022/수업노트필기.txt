IT 강남에 귀하를 초대합니다.

주제: 융합서비스 애플리케이션 개발자 양성C

회의 ID: 531 662 6199
암호: 7763







 [ 출석 미처리 ]

서진호( 아직 안옴)
임현주 (출석처리 안되어 있네요, 처리부탁)









 
  제가 목이 많이 안좋아져서, 오늘은 텍스트로 말을 작성해서 수업해도 
  될까요 여러분 ? ^_____^ 감사합니다~~

-----------------------------------------------------------------
오늘의 수업 주제 
- 패키지와 임포트 

프로젝트 새로 만들겠습니다

개발시, 사실상 원본소스와 컴파일 결과물은 반드시 구부해서 관리합니다
이때 원본소스는 src, 컴파일 결과물은 bin or classes라는 이름으로 많이사용
합니다.
따라서 현재 프로젝트에 src , bin 폴더를 만들어 주세요 
지금 작성하는 텍스트는 깃헙에 올릴께요 저장해서~
project1022/src
	    /bin	

이제 src 에 .java 소스를 저장하되, 관리목적상 패키지를 직접 만들어야 합니다
주의할것은 원본소스의 패키지는 개발자가 손으로 직접 만들어야 하고, 
컴파일 결과물의 패키지는 자동으로 만들어 집니다
src/animal 이라는 패키지 만들어 주세요 
Dog.java라는 클래스를 만들되, 패키지를 선언하셔야, 컴파일시 패키지가 
자동으로 만들어 집니다

이제 이 클래스를 컴파일해서, bin 안에 자동으로 만들어 지도록 하겠습니다.
명령어는   javac  -d  경로  Dog.java 입니다. 
시도해보세요~(cmd 에서 원본소스가 있는 곳으로 먼저 가야합니다)

이제 bin으로 가셔서 육안으로 확인해보세요 animal이 자동으로 만들어졌는지요~
자동으로 만들어졌다면 성공이구요, 개발시 일일이 콘솔에서 컴파일하기엔 효율성이
떨어지므로, 툴을 이용하여 이 작업을 진행합시다
editplus에서 툴에 등록해야 합니다... 참고로 매 프로젝트마다 하셔야 합니다.
어제한것은 못 씁니다. 이것도 불편하다면 앞으로 이클립스 쓸거니깐 염려놓으시구요!

이렇게 글로 수업해도 괜찬죠? ㅎㅎㅎㅎ 감사합니다.오히려 좋을 수도 있어요
수업이 기록됩니다.~이제  editplus 로 갑시다~~등록하러

새로운 그룹을 선택하고, 원하시는 이름을 부여합니다
저는 프로젝트 이름과 동일한 이름을 부여할께요 project1022

이제 컴파일러와 명령어를 등록합니다.
컴파일환경을 등록하신 후엔 꼭 사용할 그룹을선택하셔야 합니다.
어제 개발하던 환경에서 오늘 등록한 그룹으로 선택을 바꾸세요 

다 된거같네요, 이제  bin/animal을 지우고  재컴파일 해보세요 , 생성되는지 체크
ctrl + 1 눌러서 컴파일 시도했을때, bin/animal이 나오면 성공입니다
잘됩니다...혹시 안되시는 분 손!!!
그럼 이제 , 다른 클래스도 하나 정의해서 서로 다른 경로에 있는 클래스를 사용하는 
법을 배워볼께요 , 잠시 에러나는 사람꺼 봐줄께요
실습 시작합시다 
use라는 패키지에 ,  UseDog이라는 클래스를 정의합니다



//원래는 D:\workspace\java_workspace\project1022\bin/use 이죠?
//근데 use 앞에 bin까지를 환경변수로 등록하면 됩니다
//등록하러 갑시다
//현재 클래스와는 다른 경로에 있는 클래스를 사용해야 하는데, 
//컴파일러가 어떻게 Dog.class를 찾을 수 있는지 알아야 합니다.
//현재로서는 컴파일러가 UseDog과 같은 디렉토리만 찾아 헤맵니다.
//따라서 아래의 코드는 cant find symbol  에러 날겁니다
//이 문제를 해결하려면, 여러분들은 클래스의 경로를 알려줘야 하는데, 
//일반적으로 경로를 등록할때는 환경변수를 이용합니다 
//경로가 일반 파일일 경우는 path 환경변수 이지만, 
//경로가 클래스 파일일 경우는 classpath 환경변수를 이용하면 됩니다.
//이때, classpath 환경변수에 어느 경로를 등록해야 할지 고민해보세요 
//외우지 마시고 , 간단히 생각해보세요 현재 UseDog 클래스와 Dog
//클래스에서 우리가 생략한 경로가 무엇인지 확인해봅시다, 위를 보세요

기존에 이미 환경변수 classpath 에 등록된 경로가 있을때는 지우지 마시고
세미콜론으로 연결하시면 됩니다. 그리고의 뜻이에요 
경로;경로2;경로3....이런식입니다
일반적으로 환경변수가 등록되고 나면, 윈도우 OS가 모든 프로그램을 대상으로 
broadCasting을 합니다(바뀐내용을 방송하는 행위) 따라서, 바뀌기 전에
열어놓았던 모든 프로그램은 종료했다가 다시 열어야 하므로 editplus를 껏다켜세요
윈도우10서부터는 환경변수에 세미콜론으로 두개이상의 경로를 등록하면
저렇게 목록으로 보여줍니다. 따라서 당황하지 마세요 저게 더 편한겁니다

이제 UseDog을 컴파일 해보세요 
지금 에러가 또 찾을 수 없다고 한것은 왜그러냐면, 나와는 다른 경로에 잇는 클래스는
반드시  import 문도 함께 작성해야합니다.
클래스 package 선언부 아래에 여러분이 사용하고픈, 클래스의 경로를 명시하세요

import  bin이하의 경로를 명시합니다.
사용하고픈 클래스의 package 선언과 일치합니다

이제 컴파일 시도해보세요~
지금또 에러가 나는데, 이것은 정상적으로 인식한 에러입니다.
단지, 패키지에 들어간 클래스는 반드시 외부에서 접근할 수 있도록 접근제한을
풀어주셔야 하는데, 우리는 그걸 하지 않았어요..
지금부터 Dog 클래스를 외부에서 사용할 수 있도록 접근제한을 풀어주고 좀 쉬었다
합시다
--------------------------------------------------------------
2교시 
--------------------------------------------------------------
1교시에는 아래의 두가지를 배웠습니다.
1) 컴파일시 원하는 경로에 클래스 생성하는 법
2) 다른 경로에 있는 클래스 사용하는 법( import, classpath 이용) 

2교시에는 패키지 사용시 클래스 실행하는 법을 알아봅니다 
일단 명령어 원칙은 아래와 같습니다.
패키지 사용안할때) java  클래스명
패키지 사용할때) java  패키지경로.클래스명  

cmd 창에서 먼저 명령어를 실습해보고,  editplus 에 등록하겠습니다
cmd 창 열어보세요 어때요? 아무데서나 UseDog클래스를 사용할수있어요
이유는 환경변수에  classpath 를 등록했기 때문이에요 
그런데 로직이 없으니깐, 아무런 반응이 없네요 ,
로직 추가합시다 ( 잘되는게 확인됩니다) 

이제 이 실행 명령어도  editplus 툴에 등록해서 편하게 개발합시다 
이제 실행해보세요 ctrl + 2
프롬프트에서 물어보네요, 실행할 UseDog클래스가 소속된 패키지명이 뭐냐고
use 잔아요?  따라서  use라고 입력하고 엔터치세요 
잘됩니다.
당분간은 이클립스라는 전용 툴을 쓰지 않고, 이렇게 혹독한 훈련을 진행할 거에요 
이 과정은 매 프로젝트마다 하셔야 합니다.. (실력도 좋아짐 ) 
에러나는 분 손! 노트필기 공유했습니다
지금부터는 제가 과제를 드릴테니, 여러분이 실습해보시는 겁니다.
-----------------------------
실습과제 (10시 35분까지 진행) : 같이 해봅시다 
-----------------------------
1) 새로운 프로젝트 디렉토리를 만든 후 그 안에 원본소스 src, 컴파일결과물 bin
    디렉토리를 둔다 (O)

2)  src의 원본소스를 컴파일하면 bin으로 자동으로 들어갈 수 있도록
      editplus에 컴파일 도구를 등록한다 
      
    1) editplus 에 
      D:\workspace\java_workspace\packagetest\bin 을 등록합시다 

    2) 이 경로를 환경변수에도 등록합시다 
         이 경로가 이 프로젝트의 루트 클래스패스가 됩니다.
      classpath값에 D:\workspace\java_workspace\packagetest\bin
      를 추가해주세요
      제일 위로 올라오게 해주면, 클래스명이 중복될경우에 우선순위를 갖게 됩니다.
      (필수는 아님)
    3)환경변수가 바뀌면, 관련된 프로그램도 종료 후 다시 켜셔야합니다.
         cmd, editplus 등을 닫앗다가 열어주세요 
  
3) src에 Cat이라는 클래스를 pet이라는 패키지에 두고  eat() 메서드 추가한후
     컴파일 한다 (O)

    check)
     고양이 클래스는 다른 외부의 클래스가 사용할수 있도록  public 으로 선언해야 합니다.

4) src에 UseCat이라는 클래스를 study 라는 패키지에 두고 main() 메서드
     메서 고양이의 eat() 메서드를 호출하는 코드를 작성하고 컴파일한다 

     UseCat 만들러 갑시다 
     UseCat 컴파일 해보세요 
     정상적으로 됩니다. 
    안되시는 분 손!!

5)  editplus 도구에 실행명령어를 등록하고 ctrl+2로 실행해본다 

     java   패키지명.클래스명   을 editplus 에 등록합시다

복습까지 마쳤습니다.
이렇게 공부하지 않으면 나중에 개발자로 취업했을때, 이클립스 없으면 개발을 못해요..
실제 현장에 나가서, 리눅스나 특정 os에 개발툴 없이 컴파일 해야할 경우가 많은데,
이클립스는 서버에 설치되어 있지 않아요..그래서 이런 개념조차 없으면 개발자도 아님 ㅋㅋ
원래 서버는 그냥 서버로서 수행만 하지 개발용이 아니라서, 서버는 까만화면에 흰글씨만 나오는
콘솔환경입니다...따라서 이 실습이 중요해요..대부분의 학생들은 곧바로 이클립스로 수업을 받아서
이런 능력이 없어요..꼭 연습하세요!!!!!! ^^

이제 문제풀이의 시간입니당
구글 드라이브에 패키지와 임포트라는 파일을 올려놓앗습니다, 열어주세용!~

-------------------------------------------------------------
구글 드라이브 문제 풀이 노트
-------------------------------------------------------------
패키지와 임포트
1
다음 설명 중 틀린 것은?

강하영씨가 1번 알죠?
(1) 같은 디렉토리내의 파일명은 OS차원에서도 중복을 허용하지 않으므로 클래스를 하나의 디렉토리에 
     계속 누적하다 보면 클래스 명의 중복을 피하기란 쉽지 않다. (맞아요!!)

고준씨 -맞아요 O
(2) 클래스 명의 중복을 원천적으로 방지하기 위해서는 서로 다른 디렉토리로 구분하여 저장하면 된다.
   
권용은씨 - 맞아요 O
(3) 관련성 있는 클래스들을 디렉토리 단위로 구분하여 모아놓는 관리방법을 패키지라고 한다.

우리 호흡이 척척맞네요 ㅋㅋ
김범진씨가 합시다 - 맞아요 O (디렉토리로 구분하면 절대 중복문제가 없지요, 사진파일도 그렇고..모두)
(4) 클래스 파일명이 동일하더라도 패키지가 다를 경우엔 중복의 문제는 발생하지 않는다.

김수연씨 - 그렇죠  X 죠 , import 문을 사용하면 다른 패키지의 클래스를 사용할 수있어요 
               단, 해당 패키지에서  public 으로 공개했을때만 가능합니다.이것을 접근제한자라고 하고,
               오늘 배울겁니다
(5) 서로 다른 디렉토리에 존재하는 클래스간의 접근은 불가능하다.

김완수씨 - 맞아요 O
(6) 패키지화하여 관리하는 목적은 중복도 피하고, 관련성 있는 클래스들 간의 관리 목적 때문이다.


2
아래 클래스에 대한 설명 중 올바르지 않은 것은?

package pack1;
class  Car{
   int price=300;
}

김용씨 -  맞아요 O 
(1) javac –d 옵션으로 컴파일을 수행하면 pack1 이라는 패키지가 자동으로 생성되면서 그 안에
    Car.class를 생성하여 준다.

김재성씨 - 네 맞아요 O
               editplus 에서 ctrl+1을 여러번 누르면 오직 한개만 생성됩니다. 덮어쓰는 거죠
(2) 만일 이미 pack1 이라는 패키지가 존재한다면 중복 생성되지 않는다.

김지언씨 - 맞아요 O 이 클래스는 public 으로 접근제한을 풀지 않아서, 아무도!!! 쓸수 없습니다.
              앞으로 패키지에 넣는 클래스는 무조건  public으로 해주세요~~!
              아마 이런질문 하시는 분 계실걸요, public으로 하면 보안이 뚫리는거 아니냐하고요!
              클래스는 공개하되 , 안에 구성된 변수와 메서드를 막으면 되는거라서 , 클래스는 열여놓아도
              상관 없습니다.
              예)  은행강도가 많다고 은행문 닫으면 안됩니다..

(3) 이 클래스는 외부에서 절대로 접근이 불가능한 클래스이다.

김한나씨 - 이 문제는 배우지 않았으므로, 그냥 넘어갑니다 ㅎㅎ 죄송해요 
               답은 말씀 드릴께요 답은 틀리다 입니다.  default 접근 제한자가 지정됩니다.
               이따가 배울거라서, 그냥 넘어가겠습니다.
                              
(4) price 멤버변수에 접근 제한자가 지정되지 않으면 자동으로 private 으로 지정된 것과 같다.


3
위 3번의 클래스가 실제 하드디스크 D:\minjava\pack1 에 들어있다고 가정할 때 import 문으로 올바른 것을 모두 고르면?

맞다O  틀리다X로 대답하시면 됩니다.

박재헌씨 그렇죠 틀립니다 X , 아래에서 틀린 이유는?  
 D:/   ← 이 표현 자체가 윈도우 용이므로 자바의 슬로건에 위배됩니다. 자바는 특정 OS 에 의존하지 
하면 안됩니다.              
(1) import D:/ minjava    

박재현씨 - 그렇죠 틀립니다 X 
               이유는? 자바의 패키지는 일반 디렉토리와는 달리 디렉토리 구분은 점(.)으로 합니다
               또한 클래스명이 빠져있습니다
               따라서  import minjava.pack1.클래스명;  


(2) import minjava /pack1

배성민씨 -  그렇죠 틀립니다 이유는 이미 설명했으므로 생략
(3) import pack1;

손동진씨 - 그렇죠  X
(4) import D:/minjava/pack/Car

신형진씨 - 그렇죠 O 
(5) import pack1.Car

오성규씨 - ㅎㅎ 이건 맞아요, 올바른 표기입니다. pack1  하위의 모든 것들을 지칭하는 겁니다.(가능)
(6) import pack1.*


4
다음 설명 중 올바르지 않은 것은?
윤빈씨 -  O 맞아요
(1) 클래스를 하나의 디렉토리에 몰아넣으면 클래스 명이 중복될 경우 중복 파일 문제가 발생할 수 있다.

이동규씨 - 맞ㅂ아요 O
(2) 관련 있는 디렉토리로 비슷한 업무의 클래스들을 묶어 놓는 것은 관리상 효율성이 있다.

이동열씨 - 맞아요 O 
              실무에서는 패키지명을 우리 공부한것처럼 단순하게 하지 않고요 
              다른 회사와 협력할때, 서로 패키지와 클래스를 주고받는 경우가 잇는데, 
              이때 참 운이 없게도, 내가 만든클래스와 패키지명이 다른 회사 직원것과 완전 똑같을수도 있
               거든요,,이때는 문제가 발생하죠..덮어써버리니..
               이런 문제를 해결하기 위해, 개발자들 사이에서는 자신의 회사 도메인을 거꾸로 뒤집은 패키지를 일단 상위 패키지로 둡니다.
예)   test.com 이라는 도메인을 보유한 회사라면,  com.test.study 이런식으로 뒤짚습니다
(3) 패키지 명은 소문자로 하되, 주로 개발 밴더사의 도메인을 거꾸로 기재하여 배포한다.

이성윤씨 - 음..이건 오늘 배울건데, 아래처럼 보안이 뚫리는 경우가 있으므로, 접근제한자로 제한을 둘수
              있습니다. 답은 틀리다 입니다 X 언제든지라는 표현이 잘못됨..
(4) 같은 패키지 내에 있는 클래스들 끼리는 언제든지 서로의 데이터를 접근할 수 있다.

이 노트 계속 공유할께요. 책한권 분량 타자치는거 같아요 ㅜㅜ


남은 시간동안 배울 과제는 접근제한자 입니다.
------------------------------------------------------
접근 제한자
 : 클래스내에 작성되는 변수는 지금까지는 색상,가격 이런 기본적인 연습용 데이터엿지만
   사실상 자바 개발자가 현업에서 다루는 업무는 주로 계좌, 고객정보 등 상당히 민감한 데이터를
   다룹니다. 따라서 클래스내에 있는 변수는 데이터이므로 보호받아야 합니다.
   자바에서는 이렇게 데이터를 보호할 수 있는 보안 장치를 지원해 주는데, 이를 가리켜 접근제한자
   라고 합니다.

접근제한자의 종류 
    약한것 순으로 나열하자면 

   public(보안도 아님 그냥 공개임)
   protected (상속관계에 있는 부모자식 클래스끼리만 접근 가능) 
   default (같은 패키지 안에 있는 클래스끼리만 접근 가능, 상속받았다 할지라도 같은 패키지가
                   아니라면 접근 못함)
   private (같은 클래스내의 멤버끼리만 접근 가능 )
                  예) 멤버메서드가 멤버변수에 접근  
  결국 보안 순서는 이렇게 보시면 됩니다. 
  public < protected < default < private 
 
  이렇게 적어드리면, 마치 개발할때 개발자가 보안을 철저히 따져가면서 클래스를 만들거 같지만
  사실 private을 많이 쓰시게 될거에요..곧 보시면 압니다..
------------------------------------------------------
실습해봅시다!!
고객의 "계좌"라는 주제를 가지고 클래스를 정의해 봅시다 

/* use 패키지에서 Account 계좌클래스를 접근해보겠습니다.*/


/*질문) 현재 클래스는  public 으로 공개해야 할까요, 하지않아야 할까요?
O, X ? 현재 클래스는 사용을 당하는 클래스인가요? 사용하려는 클래스인가요?
그렇죠, 사용을 하려는 쪽은 공개가 될필요가 없죠...사용당하는 쪽만 공개하면 됩니다
결론은 이 클래스는 공개할 필요없겠네요..
UseAccount(사용하려는 객체) --->  Account(사용당할 객체) 공개되어야 함
*/
package use;
//사용하려는 클래스의 위치 알려줍니다.
import bank.Account; //bank 이전의 경로는 이미 classpath 에 등록되어있죠..
class  UseAccount{
public static void main(String[] args){
Account acc = new Account();//계좌 클래스 생성 (public 이라 여기까지는
//무조건 가능함)
//이제 접근제한자 별로 접근해보겠습니다. 

//bank 은행명은 public 으로 선언되어 있으므로, 무조건 접근이 가능하겠죠? 
System.out.println(acc.bank);//잘 나옵니다..당연합니다  public 이므로..

//customer는  protected로 선언되어 있으므로 상속관계에 있거나, 같은 패키지
//경우에만 접근이 가능합니다..현재  UseAccount는 Account와 상속관계가 없고
//서로 다른 패키지이므로, 데이터 접근이 불가능할 겁니다.테스트해보세요 
//컴파일시 에러 나는거 보이시죠? customer has protected access in Account
//System.out.println(acc.customer); 주석처리 하시고 그 다음 변수 테스트합니다

//계좌번호 num변수는 ,개발자가 아무것도 명시하지 않았는데요, 이러한 접근제한자를 default
//접근제한자라 하고, 여러분들이 default 라는 키워드를 명시해서는 안됩니다..그냥 냅두셔야 합니다
//default 접근 제한자는 같은 패키지에 있는 클래스끼리만 접근을 허용해주므로,  protected보다
//한단계 더 까다롭습니다. (즉 상속관계에 있어도, 같은 패키지가 아니라면 접근 불가임..)
//System.out.println(acc.num);	//컴파일해 보세여
//num is not public in Account, cannot be accessed from outside package
//"공개되어 있지 않으므로 외부에서 접근이 불가능합니다" 라는 메시지가 나옵니다.
//우리가 지금까지 실습했던 모든~~~클래스가 사실 default 였고, 우리는 같은 디렉토리에서
//실습을 해왔기 때문에 지금까지 이런 에러를 만나지 않았던것 뿐이에요..이제 패키지를 사용하기 
//때문에 접근제한자를 조금 아셔야 합니다 

//계좌 잔액 balance 를 테스트해 봅니다 .
//balance는 가장 강력한 접근제한자인 private이 적용되어 있으므로, Accont 클래스 스스로
//만 접근이 가능합니다..따라서 우리는 Account 자신이 아니라서 ,절대 절대 사용못합니다..
//완전 폐쇄적이죠..
System.out.println(acc.balance); //컴파일하면 에러납니다.
//balance has private access in Account(private 접근제한자가 적용되어 있다는 의미)

//이제 다실습했으니 대충 누가 더 강력한 접근제한자 인지 아시겟죠? 
//공부하실때는 public 은 그냥 빼고 공부하세요, 퍼블릭은 보안 자체가 없는거니까요.. 
//한가지 궁금해집니다..private 은 너무 강력해서 아무도 못쓰는데 그럼 왜 만든것일까요?
//그림 하나 그리겟습니다...
}
}

여기에 다 몰아넣었으니, 집에서 혼자 읽어보실수 있겠네요 

저 돼지가, 만두를 4개 갖고 있습니다.
public은 모든 사람이 다 먹습니다.
돼지도 제한을 못해요, 

protected 는 돼지의 자녀까지만 먹습니다.
자녀가 아니면 못먹어요, 단 자녀가 아니더라도 
같은 집에 세들어 사는 사람은 먹어요..

default 는 자녀고 뭐고 안봐주고 그냥 세입자만
먹어요, 

private은 저 돼지 혼자만 먹어요

그럼 저 private으로 선언된 만두에 손을 대려면?
-오직 돼지밖에 손댈수 없기 때문에 돼지를 이용해야
합니다...즉 간접적으로만 접근할 수 있어요..
지금부터 그 실습을 하겠습니다~~
저그림도 저장해놓을께요..


학생분 질문) 
 그럼 즉 만두가 필드,생성자,메소드 모두를 포함한 하나의 형태라고 보면될까요?
 답변) 아 예를 들다가 너무 크게 잡았네, 저 만두를 클래스 안의 변수라고 봅시다
         모두 같은 클래스 안에 있다고 생각하세요~!~! ok?

//private으로 선언된 변수는 절대 아무도 외부에서 접근할 수 없으므로
//변수에 접근하려면, 메서드를 이용해야 한다..
//이 원리는 일상생활에서 찾아보겠습니다..

집에서 어머니가 얘야 다른거 보자 하시면, 저렇게 핀셋으로 전기 자극을 일으켜서
채널을 돌리시나요? ㅋㅋㅋ
지지직~~~~
 여기서 알수있는게 뭐냐면, 우리가 사용하는 전자제품들이 저렇게 노출되서 판매되지 않고
예쁜 포장, 껍데기가 있지 않나요? 케이스요!~~

이렇게 케이스가 달려서 나오는 이유는 여러가지가 있어요.
1) 내장부품은 소중하기 때문에 , 노출되면 망가집니다. 
2) 일반인들은 데이터내부적인 지식이 없기 때문에, 손쉽게 조종하기 위해서는 
     껍데기를 감싸서 , 조작방법만 익히면 됩니다. 즉 버튼만 누르면 됩니다.
     조작방법은 곧 방법이 영어로 메서드이니깐, 결국 메서드를 통해서 물건을 제어하면 됩니다.

결론) 우리가 작성한 클래스에서 메서드없이 변수를  public 으로 노출시키는 행위는 
      리모콘에 껍데기가 없는 것과 같다~!!! (이것만 기억하세요)
      그래서 소중하다고 생각되는 변수는, 외부에서 직접 접근할 수 없게 무조건 private 으로 
      막으시고, 이 변수에 대해 간접적으로 접근할 수 있는 방법은 메서드를 통해 제공해주세요 
      이걸 보고, 은닉화 영어로는 캡슐화라고 합니다...아주 아주 많이 씁니다...
    이제 우리 Account 클래스를 캡슐화 합시다!!!
//아무도 못쓰게 막았으니, 현재 Account 클래스 스스로만 접근할 수 있어요..
//따라서 멤버메서드를 제공해줍시다 
//아래와 같이 해주세요..
public void setBalance(int balance){
	this.balance = balance;
}
    
      
acc.setBalance(10); //10원으로 수정 , 이 방법은 메서드를 통해 접근이므로 가능
//이제 잔고가 수정이 된겁니다..
//그런데 수정된 잔고를 어떻게 확인하나요? 변수에 접근을 막았으니...
//잔고 수정이 아니라, 잔고에 접근하려는것 또한 메서드를 제공해주셔야 합니다. 
//마치 리모콘에서 채널 전환버튼만 있는게 아니라, 현재 채널 확인버튼도 있듯이요~

접근제한자 수업 정리합시다 

접근제한자는 자바에서 보안을 처리하기 위한 방법을 제공합니다.
여기서 특히 prviate 의 활용도가 상당히 높습니다.
사실상 클래스내에 선언되는 변수는 모두  private 하는게 많아요 .
왜냐면 아까 얘기햇듯이 데이터는 보호되어야 하니까요..리모콘처럼 내부 장치는 덮어놓아야 합니다.
이 내부장치를 외부에서 제어하려면 접근 "방법"을 제공해주어야 하는데 그게 바로  getter/setter메서드
에요, 그리고  데이터를 private보호하고, 오직 getter/setter 를 통해서 데이터를 간접 제어할 수 있도록
클래스를 정의하는 기법을 가리켜 객체지향 OOP에서는 은닉화(=EnCaptualation)캡슐화라고 합니다

근데 쉬는시간에 학생분 한분이 질문을 햇어요...
요지가 뭐냐면, setter/ getter를 어차피 제공하면 private 으로 막아놓았던 변수에 결국 외부의 주체가
접근하게되는 건데 의미가 있냐는 거죠...어떻게 생각하시나요 여러분들은? 내가 예전에 공부할때
이 질문에 아무도 대답 안해줌이요.. 생각해보니 이런 결론에 이르렀음..
예제를 보면서 설명할께요 

//아래의 변수는 아무도 직접 접근못하게 일부러 보안을 강화햇음..
private int balance=100000; 
그런데, 막상 setter/getter를 이용해서 외부의 침입자가 제어할수 있다면 하나 마나 한짓 아닌가?
라는 생각을 하게됨..여러분도 그러함? 살아계시나요 ? ㅋㅋ 그쵸 바로 그거에요 
제한을 가하면 됩니다...
잘보세요 

누군가 계좌의 잔고를 0으로 바꿀려고 하는 악의를 가진 객체가 있다고 합시다
acc.setBalance(0); //나쁜짓입니다..

근데 메서드에서 뭔가 제한을 가하면 되지 않을까요?
public void setBalance(int balance){
	//만일 나쁜놈이 이상한 짓을 하면...조건을 주면 됩니다..
	if(balance >0){ //이런식으로요....이건 그냥 대충예를 제시한것고 복잡하게 뭔가 더 줄수있겠죠?
		this.balance = balance;
	}
	마치 리모콘에서 이용자가 쓸데없는 짓을 하면 기능에 제한을 가하듯....	
}
이해가 좀 되시나요? 결론은 메서드를 통해 얼마든지 방어할수 있다는 거에요~~ understood? good!!
-------------------------------------------------------------------------------------
이제 문제풀이 시간을 갖겠습니다.
구글 드라이브에 접근제어라는 파일 열어주세요~~
곧바로 문제풀이 하겠습니다.
아까 어느분까지 했는지 기억이 안납니다...자진 납세합시다..ㅋㅋ 고맙습니다 


문제1) 아래와 같은 계좌 클래스에 대한 설명 중 틀린 것은?
public class Account {
	int balance=200; //(가)
	String bank="기업은행";
	String accountNum="12-456-789-10";
	
	public int getBalance() { //(나)
		return balance;
	}
	public void setBalance(int balance) { //(다)
		this.balance=balance;
	}
}

이어진씨- 이 문제는 외부의 클래스가 접근하려고 할때  default 를 접근할 수 없으므로 X 입니다.
            잘하셧어요~
(1) (가)의 balance 를 외부의 어떤 클래스가 사용하려면 .점찍고 접근하면 된다.

임현주씨 - 그렇죠, 직접 접근못하니깐 메서드를 통해 방법을 제공해야 합니다. 따라서 O
(2) balance를 외부의 어떤 클래스가 참조하려면 (나)의 메서드를 호출하면 잔고값을 얻어갈 수 있다

장형규씨 - ㅋㅋ 문제 유치하네요, 틀린말입니다 X 
(3) 외부의 클래스가 점찍고 balance 변수에 접근하면 됨에도 불구하고, (나),(라)처럼 값을 반환받거나
    변경하기 위한 메서드를 정의하는 것은 시간 낭비이다.

 변수에 대해 사용자체를 막아버리면, 변수를 정의하는것 자체가 무의미해집니다..
 따라서 자바의 목적은 쓰라고 만든 것이지, 그냥 관상용으로 만드는 것이 아닙니다.
 따라서 쓸수 있는 기회를 제공해주어야 개발의 의미가 있는겁니당 따라서 틀린설명이죠 X
(4) private 으로 멤버 변수를 제한해두면 외부의 클래스에서 변수에 대해 접근 자체가 불가능해지며, 
   이렇게 변수 자체를 아예 사용 못하게 하는 것이 자바 보안의 목적이다.

조혜씨 - 맞아요~~~O
(5) 메서드를 통해 클래스가 가진 변수를 접근하는 방법은 좋은 방법이다.


문제2)
다음 설명 중 틀린 것은?
최시민씨 - 그렇죠 맞습니다 O
(1) 클래스의 멤버 변수는 결국 데이터 이므로 보안상 보호되어야 할 대상이다.

최은영씨 - 그렇죠, 멤버메서드가 접근못하는 변수는 없습니다~~왜냐면 같은 몸에 붙어있잔아요 
             여러분 다리 가려울때 다리 못 긁나요? 내몸에 붙은 모든 신체 기관은 같은 몸에 붙어있으므로
	     서로 접근이 가능합니다~~
(2) private 으로 선언된 멤버 변수는 같은 인스턴스내의 멤버 메서드라 할 지라도, 접근이 불가능하다.

최준혁씨 - 네 틀린말이죠 아까랑 같은 문제네요..
(3) private 으로 멤버 변수를 제한해두면 외부의 클래스에서 변수에 대해 접근 자체가 불가능해지며, 
   이렇게 변수 자체를 아예 사용 못하게 하는 것이 자바 보안의 목적이다.

탁승연씨 - 네 맞습니다 O
(4) (3)번의 경우처럼 변수 자체에 대한 사용을 금지시킬 경우, 클래스를 정의한 목적 자체가 무의미해 
   지므로, 변수 사용에 대한 접근 허용을 개발자의 선택에 따라 임의로 조절 가능하도록 하기 위해,
   메서드를 통해 간접 사용하게 하는 방식을 객체지향에서는 은닉화 또는 캡슐화(=encapsulation)
   라고 한다.

황유미씨 - 그렇죠 맞습니다 O
(5) private으로 접근을 제한한 변수에 대해 값을 변경할 수 있도록 제공되는 메서드를 setter라 하고
   값을 접근하여 반환할 수 있도록 제공되는 메서드를 getter 라 한다.

문제3) 여러분들이 직접 해보세요~~
근데 제가 한가지 알려드릴것이 있어요 
은닉화에 작성되는 메서드 정의 표기법은 정해져 있어요 규칙이요~

ex)  private  String name; 
      private String price;

getter와  setter 작성시 합성어는 뒷단어의 첫 철자를 대문자로 해야 한다는 규칙이 있습니다.
저 예제에 대해 총 4개의 메서드를 같이 만들어봅시다 

name에 대한  getter/setter

//set 다음에 N이 대문자 입니다. 뒷단어의 첫 철자이기 때문에요~~낙타 등기법
public void setName(String name){   
	this.name=name;
}
public String getName(){ //get다음에  N대문자, 같은 원리입니다..그리고 게터는 반환값이 있습니다
	return name;
}
public void setPrice(int price){
	this.price=price;
}
public int getPrice(){
	return price;
}
참고로 이클립스라는 툴은 이 getter/setter를 대신 만들어줍니다. 만드는데 0.2초 걸립니다
그러니깐, 나중에 그렇게 하기로 하고 ,일단 직접 써보세요 

총 6개의 메서드를 정의해주세요~~~

아래의 클래스에 모두 private을 붙여야 합니다 
데이터는 보호하되, 보호된 데이터에 대한 getter/setter를 제공해주는게 은닉화입니다
class  Customer{
    private String name;
    private int age;
    private boolean isMarry;
}

public void setName(String name){
	this.name=name;
}
public String getName(){
	return name;
}
public void setAge(int age){
	this.age=age;
}
public void setIsMarry(boolean isMarry){
	this.isMarray=isMarray;
}
public boolean getIsMarry(){
	return isMarry;
}
이 메서드 정의 패턴은 이미 정해진 것이라 규칙을 지켜주세요~~

4번문제는 생략하겠습니다.

다음주 월요일쯤이면, 문법이 끝날거 같아요, 그럼 무조건 무얼 만드는 수업이에요..좀만 참으세요 
구글 드라이브에서 클래스간 관계라는 파일을 열어주세요~

----------------------------------------------------------------------
클래스간 관계 문제풀이
----------------------------------------------------------------------
문제1)
아래의 (A)에서 Computer 클래스는 메모리에 올라갔으나, 부품으로 보유한 Ram, HardDisk 는 아직
메모리에 올라가지 못한 상태이다. (B)라인에 알맞는 코드를 작성하여 com의 부품도 메모리에 
올라가도록 처리하라.

이 문제를 각자 풀어보세요~~코드를 작성해주세요

혹시 아래와 같이 클래스가 특정 클래스를 멤버로 보유한관계를 무엇이라고 하는지 아시는 분 대답해주세요
그렇죠, has a 관계입니다.
has a 관계에서는 변수로 선언된 객체들은 부품과 같으므로, Computer 가 태어날때 부품도 같이 태어나게 해주는게 좋아요
따라서 원래는 생성자를 통한, 부품 초기화가 가장 이상적이겠지만, 아래의 예제에서는 그게 없죠..
없는거 내에서 코드를 완성해보세요.. 

class Computer{
    Ram ram;
    HardDisk disk;

    //올바른 초기화 방법 
    //생성자를 적극 활용하는 것이 좋다 왜? 컴퓨터가 제조될때 부품도 같이 조립되어야 하니깐 생성타임을 놓치면
    //컴퓨터 껍데기 생성 후, 나중에 부품을 추가하는 느낌이니깐..
    pubilc Computer(){
	ram = new Ram();
	disk = new HardDisk();
    }
}

class UseComputer{
    public static void main(String[] args){
      
         Computer  com=new Computer(); (A)
	 	
         (B) 무식한 방법 
	 com.ram = new Ram();
	 com.disk = new HardDisk();
    }
}

문제3 으로 바로 넘어갑니다. 2번을 풀지 마세요 
문제3에 대한 설명은 하지 않고 진행할께요, 우리 술자리 가면 눈치게임 아시나요? 
어떠한 설명도 없이 그냥 눈치껏 답을 말하세요..센스 체크 ^^
시작합니다~~~~~~~
Ex)  오리 --------  새
(1) 한국인  --------- (  사람       ) 강하영씨 굿
(2) 승용차 -------- (       차 ) 고준씨 굿
(3) 얼룩말  --------- ( 말 ) 권용은씨 ㅋㅋㅋ, 맞아요근데 너무 위로 갔다 ㅋㅋ넹
(4) 손목시계 -------- (     시계    ) 윤기씨 굿
(5) 종이컵   -------- (   컵   )  범진씨 굿
(6) 운동화  --------- (    신발 )  수연씨 굿
 (7) 외과,내과 의사 ---- (    의사   ) 완수씨 굿
(8) 민법 -------------(    법   ) 김용씨 굿
(9) 피아노 -------------(   악기    ) 재성씨 굿
(10) 동화책 -------------(    책    ) 김지언씨 굿

우리 지금까지 뭐한건지 아시는분 ?
ㅋㅋㅋㅋ
오~~아시는분이 있네
자바가 다루는 대상은 사물이죠? 현실의 사물이 단독으로 존재하는 경우를 말할 수 있는 사람은 제가
내일 빕스 쏩니다...
그니간 어떤 대상이 단독으로 존재하는 경우를 말씀해보세요 
예를 들어 심지어 볼펜 마져도 펜, 손잡이, 볼 이렇게 부품으로 이루어져 있거든요..
그리고 볼펜은 팬의 한 종류구요..정확히 펜의 하위분류죠..
공기? 공기는 제가 알기론 수소 산소 조합아닌가요?
근데 여러분이 자꾸 답을 맞추려고하면 안ㄷ돼요!! ㅋㅋㅋ
이건 맞추지 말라고 내는 거잔아요 
빕스 ㅋㅋㅋ

우리 쉬었다 합시당~~

오후 신호발송 하겠습니다~~
-----------------------------------------------------------------------
6교시 수업 
-----------------------------------------------------------------------
수업시작하겠습니다.

쉬는 시간 되기 전에, 우리 눈치게임 했었는데요, 
제가 던지 주제가 바로 이거였죠 
"모든 사물은 단독으로 존재할 수 없다.."  철학적인 말같죠

객체지향 언어인 자바에서는 모든 사물을 단독으로 존재할 수 없다는 관점을 2가지 경우로 나누어 생각합니다
(is a , has a 개념은 ocjp 시험에 나옵니다) 
1) is a 관계 :  ex)  Duck is a Bird  "오리는 새다"
                         상속관계를 나타내는 말입니다.

2) has a 관계  : 자동차는 바퀴를 가지고 있다. Car has a Wheel 
                       부품관계를 나타내는 말입니다. 
		       부품관계란, 특정 객체가 , 다른 객체를 멤버변수로 보유한 경우를 말해요 

그래서 오늘 수업주제가 바로 is a, has a 인데, 우리는 지금까지 has a를 많이 다뤘죠?
저 위에 computer 예제가 바로 has a 였습니다.

이제 is a 공부해볼께요 

문제4번을 풀어봅시다 각자 (5분 드립니다)
현실의 자동차, 택시, 버스, 트럭을 자바 언어로 반영하되 재사용성을 고려해서 설계해 보세요

같이 해봅시다~~
초보자가 저 상황을 설계하게 되면 아마 코드 중복이 발생할거에요 .

우측 그림처럼 설계 하신 분 손 !!
ㅋㅋ
지금부터 만들어봅시다 상속 이용할께요~~
car 패키지에 모두 넣어줍시다 

/* 파일 저장하실때, 자꾸 파일명과 클래스명이 틀리시는 분이 많아요
아래의 "Car" 단어를 더블 클릭한 후, 컨트롤 copy 한 후,   컨트롤 s 눌러보세요
그러고 붙여넣기 해서 저장하세요 car 패키지에 넣으셔야 합니다
*/
//이 클래스는 모든 자동차류의 최상위 클래스로서, 가장 보편적인 기능과 속성들만을
//보유하면 됩니다..
class Car{
	//자동차의 보편적인 메서드는 뭐가 있을까요? 
	//백밀러, move, 바퀴, 브랜드, 전후진, 배기량...몇가지 선별해서 할께요
	String brand; //제조사는 정해져있으면 안되니깐 비워두겠습니다..

	public void move(){ //자동차의 가장 필수적인 요건이죠
		System.out.println("자동차가 갑니다");
	}
}


이번엔 트럭을 정의합시다
*/
package car;
public class Truck extends Car{ //이 한줄로, 우리는 Car 를 상속받게되고, 지금부터  Car의 
									//자원들에 접근이 가능합니다..마치 내것처럼요..
	//트럭에도  move 메서드를 둬야 하나요?
	//우리가 원하는건, 예전에 작성했던 비슷한 코드를 또 작성 안하고자 하는게 목적이죠?
	//이때 사용되는 기술이 상속이잔아요...js 게임까지 만들어봤으니 모르시는분 없겠죠..
	//js 랑 똑같아요!!
	//이제는 트럭만이 갖는 특징을 작성하시면 되요...뭐가 있을까요? 
	public void dump(){
		System.out.println("물건을 대량으로 옮깁니다");
	}
}

/*
택시를 정의합니다
*/
/* 파일 저장하실때, 자꾸 파일명과 클래스명이 틀리시는 분이 많아요
아래의 "Car" 단어를 더블 클릭한 후, 컨트롤 copy 한 후,   컨트롤 s 눌러보세요
그러고 붙여넣기 해서 저장하세요 car 패키지에 넣으셔야 합니다
*/
//이 클래스는 모든 자동차류의 최상위 클래스로서, 가장 보편적인 기능과 속성들만을
//보유하면 됩니다..

package car;
//public 으로 접근을 풀어주세요 모두~~
public class Car{
	//자동차의 보편적인 메서드는 뭐가 있을까요? 
	//백밀러, move, 바퀴, 브랜드, 전후진, 배기량...몇가지 선별해서 할께요
	String brand; //제조사는 정해져있으면 안되니깐 비워두겠습니다..
	
	//부모클래스의 생성자를 정의해주세요..매개변수가 없는 이러한 생성자도 디폴트 생성자입니다
	/*
	public Car(){
		System.out.println("자식의  super()호출에 의해 난 호출됩니다");
	}
	*/
	
	//개발자가 매개변수 있는 생성자만 정의함 , 개발자가 생성자를 정의하면 컴파일러에 의한 디폴트 생성자
	//자동 삽입은 없음 
	//따라서 Car클래스는 생성자가 오직 딱 1개만 있게 됨 
	//컴파일 해주세요 다시! , 이제 Taxi 를 new 할때 에러가 발생하겠죠? 
	public Car(String brand){ //매개변수 있는 생성자라서, new Car("벤츠") 등 방법으로 호출해야함
		this.brand = brand;
	}
    

	public void move(){ //자동차의 가장 필수적인 요건이죠
		System.out.println("자동차가 갑니다");
	}
}








/*실수로 패키지 선언을 안했어요...ㅜㅜ*/
package car;

public class Bus extends Car{ 

	//버스만이 갖는 특징 정의합니다.
	public void line(){
		System.out.println("노선을 따라갑니다");
	}
}

이제 모든 객체를 설계했으니, 메모리에 올려놓고 사용해봅시다!!
모두 컴파일 해주세요~~
제일 먼저 어버이(부모)인 Car 클래스먼저 해놓으셔야죠? 
4개의 클래스를 컴파일 완료하셨으면, 이제 실행부가 있는 클래스 하나 정의해서 사용해볼께요 
use 패키지에 UseCar라는 클래스 정의해주세요 



package car;
public class Taxi extends Car{
	/*이미 Car를 상속받았으므로, 여기서도 마찬가지로 택시만이 갖는 특징만 추가하면 됩니다.
	코드량이 현저히 줄고, 중복작성 하지 않아도 되므로 유지보수하기에 좋아요..oop언어의 목적은
	바로 상속입니당...
	*/
	//현재 택시 클래스에는 생성자가 있나요 ?? 여러분? 잇따 없다 ? 디폴트 생성자가 컴파일러에 의해
	//관여 됩니다..왜? 적어도 에러는 안나야 하니까요..
	/*
	눈에 보이지는 않지만, 컴파일러에 의해 디폴트 생성자가 아래와 같이 아무것도 없는 로직 상태로 
	존재하게 됩니다.. 그래야 new Taxi() 할때 에러가 안나니깐요..
	근데 문제가발생합니다..택시가 초기화하기 보다 앞서서 ,Car가 먼저 초기화가 되어야 
	상식적으로 이치에 맞지 않나요? 부모가 먼저 존재해야 하니깐요..
	그래서 sun 사에서는 눈에 보이지는 않지만, 자식의 디폴트 생성자에 보이지 않는 생성자 호출을 
	살짝 넣어둡니다..아래처럼요..
	public Taxi(){
		super();  //이 생성자 호출이 숨어 있어요!!!  
		super는 부모클래스를 의미하고  super()는 부모의 생성자를 의미합니다.(js랑 완전 같죠?)
		수업시작할께요~
		
		sun사에 의해 디폴트 생성자가 부모의 생성자를 호출하는지 증명을 해봅시다
		부모의 생성자에 무언가 동작여부를 확인할수 있는 코드를 넣어볼께요
		우리 예측이 맞죠? js랑 같습니다.
		근데, 부모인 Car에서 디폴트생성자가 아닌, 매개변수 있는 생성자만 둘 경우 조심해야 합니다.
		해볼께요
		Taxi클래스의 디폴트 생성자에서는 무조건 super()가 들어있으므로, 매개변수 없는 생성자인 
		Car()를 호출하고 있는 것과 같아요, 따라서 현재 Car에는 Car() 생성자 대신에 Car(String brand)
		만 존재하므로, 생성자 호출시 에러가 날겁니다..해결책은  js 시간에 알려드렸죠?
		여러분들이 해결해보세요 시간 1분 드립니다.

		해결책)  현재 디폴트 생성자는 우리에게 아무런 도움을 못 주므로, 이제 개발자가 주도해서 
		             원하는 생성자 호출을 직접 해야 합니다. 한마디로 디폴트 생성자에 의존하지 말라는 얘기에요
					 즉 방치하지 말라는 얘기입니다.
					 생성자 정의해주세요 
	}
	*/
	
	//부모의 매개변수 있는 생성자를 직접 호출해주기 위해, 개발자가 생성자를 정의하고 있는 것임
	/* 주석으로 막아보세요.,이렇게되면, 다시 컴파일러가 관여하겠죠? 디폴트 생성자를 만들고 그 안에서 
	super() 를 호출하게 될꺼에요,,위에서 처럼요..그렇게 되면 오버로딩된 생성자 중 두번째 꺼 
	디폴트 생성자를 호출하게 되서 에러가 안납니다..증명되었죠? Car클래스 컴파일하고 나서, Taxi  컴파일
	했을때 에러 안납니다~~!
	public Taxi(){
		super("Benz"); //매개변수 있는 생성자 호출합니다. 이렇게 하면 존재하는 생성자를 제대로 호출하는
		//것이므로, 더이상 에러가 안나겠죠? 현재Taxi 클래스 컴파일하시고  UseCar 다시 실행해보세요
	}
	*/
	
	//위와 같이 개발자가 직접 알맞는 생성자를 정의하는 방법을 추천하지만, 혹시 이런 경우도 있어요..
	//부모 클래스에 생성자를 여러개를 정의하는 거죠...그니깐 매개변수 있는것 없는것, 온갖 종류는 
	//다 정의해 놓는 거죠..오버로딩이죠
	
	//택시만이 갖는 특징 
	public void pass(){
		System.out.println("승객을 태워요");
	}
}


package use;
import car.Truck;//사용하고자 하는 트럭 임포트 
import car.Bus;//사용하고자 하는 버스 임포트 
import car.Taxi;//사용하고자 하는 택시 임포트 

//만일 위에서 처럼 일일이 명시하는게 귀찮을 경우 한꺼번에도 할수 있어요 
//import car.*;  //다시 말하지만, *의 대상이 될수 있는건 패키지명이 아니라 클래스명입니다..
					//참고로 현업에서는 *를 잘 쓰지 않습니다..저렇게 해버리면  import에서 다루고자하는
					//기술이 무엇인지 빨리 해석이 안됩니다...따라서 따로 따로 해주시는것이 좋습니다.

class UseCar{
	public static void main(String[] args){
		//질문 드립니다..
		//만일 택시를 사용하고 싶을때, 부모인 Car클래스를 메모리에 별도로 new를 해줘야할까요?
		//아닐까요?  O ,X 퀴즈
		//정답: 자식을 .new 하면 js와같이  부모는 자동으로 인스턴스가 생성됩니다..
		//정말 그런지 보겠습니다. 
		Taxi t = new Taxi();//택시의 인스턴스 생성,  얼핏보기에는 택시만 생성될 것 같지만
									//택시보다 앞선 부모인  Car가 존재해야, 택시도 존재할 수 있기때문에
									//js 시절의 원리가 그대로 적용되어 Car인스턴스도 생성된다

		t.pass();//택시 메서드 호출되는지 확인해보세요 
		//그리고, 택시 클래스 코드안에는 없지만, Car클래스가 보유한 변수가 메서드 호출해봅시다.
		//만일 호출이 되면 Car인스턴스가 생성된게 증명되는 거에요~
		t.move();  //분명 move() 메서드는 택시에 없는데도 이게 호출된다면 택시가 부모님꺼를 맘대로
						//접근한 것이지요~
						//이미 js 시절에 상속을 맛봤기에 여러분들은 다 아시는 개념이죠? 
						//남은 시간에는  5분..상속관계에서 jvm 메모리에서 어떻게 생성되는지 그려드릴께요
		//UseCar클래스를 다시 실행해보세요
		//물론 Car를 컴파일 해주세요 
	}
}

아,참고로 한거지 더 얘기할게 있어요, 꼼수
실습을 다 마쳤습니다.
개념정리 문제 풀이해볼게요.. 
 
5번문제)  누구할차례인지 잘 모르겠어요 이번엔 거꾸로 합시다 
하영씨가 저요라고 했기 때문에 계획을 또 바꿉니다
ㅋㅋ

하영씨) 어려운 문제엿어요
현실에 존재하는 객체들 중 상위 객체로부터 파생된 경우를 흔히 볼 수 있다. 
즉 자신보다 상위 개념의 객체가 존재하는 경우를 자바와 같은 OOP언어에서는 ( is a ) 관계라 하며, 
extends 키워드로 표현한다.
이때 상위클래스를 부모클래스라 하며  ( super )클래스라 하고, 자식클래스를 (  sub ) 클래스라 한다.

객체지향 언어에서는 부모를 절대  parent 라고 하지 않고 super라는 말만 씁니당~~


문제6) 
다음 설명 중 올바른 것을 모두 고르면?
class Duck extends Bird{ sun에서는 is a를 무지 강조합니다, 근데 실제적으로 is a 라고 작성하면 안되요
왜냐면 is a는 개념일뿐, 상속을 표기하는 키워드는 extends만 쓰셔야 합니다.

}
(1) 새를 부모로 둔 오리 클래스를 정의한 것이다. 고준씨 O
(2) extends를 is a 로 해석해도 문장에 무리가 없다. 권용은씨 O
(3) 클래스 선언을 Bird extends Duck 으로 순서를 바꾸어도 무리가 없다.권윤기씨  X
                      오리는 새다 (참)
		      새는 오리다 (거짓) 이 세상의 모든 새가 다 오리는 아닙니당...
	              즉 상속관계는 부모,자식의 순서를 바꾸면 큰일납니다.. 

김범진씨 - 그렇죠, 부모클래스가 먼저 존재해야 상속을 할수가 있죠 O
(4) 이 클래스가 올바로 컴파일 되려면 먼저 Bird 클래스가 컴파일 되어 있어야 할 것이다. 

김수연씨 - 그렇죠 X 입니다. 자바뿐만 아니라 대부분의 객체지향 언어에서는 부모를 parent라 하지 않아요
             근데 전산 전공자분들은 어디선가 parent 를 본적이 있을텐데요, 이 parent는 GUI 프로그래밍
	     할때, 즉 그래픽을 처리할때 컨테이너간 포함관계에서 바깥쪽 객체를 가리키는 용어로 쓰여요 
	     우리가 배운 HTML에서 div안에 img 를 넣었다면 div를 parent라고 합니다...
	     그래서 앞으로 프로그래밍시 parent라는 말이 나오면 무조건, UI쪽 다루는 구나 생각하세요!!
             이거 꿀팁 맞죠? ^^
(5) Bird 를 부모클래스라 하며 자바에서는 parent 클래스 라고 표현한다.

김완수씨 - 그렇죠 자식클래스도 child 란 말을 쓰지 않고 UI 에서 하위에 포함된 객체를 의미해요, 
             자바에서는 sub 클래스라고 합니다..꼭 기억하세용 
(6) Duck 을 자식클래스라 하며 자바에서는 child 클래스 라고 표현한다.


문제7) 같이 풀어보겠습니다

다음 설명 중 맞는 것은?
class Bird{
    String name=”그냥 새”;
    boolean fly=true;
    int legs=2;
}
//오리 클래스는 멤버변수 1개, 생성자1개 그렇게 구성되어 있습니다.
class Duck extends Bird{
     String name=”오리”;
     public Duck(String  n){ //개발자가 생성자를 명시하면, 컴파일러는 더이상 관여하지 않아요!!
     					//따라서1개입니당
         name=n;
     }
     public static void main(String[] args){
         name=”도날드”;         (가)
         Duck d=new Duck();   (나)
         d.name=”도날드”;      (다)
         d.fly=false;                (라)
     }
}

김용씨- 계셔요
질문)  현재 Duck 클래스의 생성자의 갯수는 몇개인가요? 1개
      Duck() 클래스의 생성자는 1개이고, 부모의 생성자는 내것이 아니므로 산입하시면 안됩니다.
       중요한것이 무어냐면, 부모의 생상자는 물려받지 않아요...
       왜 그런지 어디에도 설명이 안나와 있는데, 저는 아주 아주상식적이라고 생각해요 
       왜냐면, 생성자의 의미가 뭐죠? 
       각 객체가 태어날때 자신의 개성을 만들어 낼수있는 기회의 공간이잔아요? 
       근데 만일 부모의 생성자도 물려받는다고 생각해보세요, 그건 부모의 자식이 아니라 부모의 복제인간입니다 ㅋㅋ
       부모와 초기화가 같을수 있나요? 그건 그 부모님이 되는건데요? 그렇게 이해하시면 될것  같구요 
       생성 시점으로도 부모의 생성자를 마음대로 접근할수있다는 것도 상식적이지 않아요..
       하여간 알아둡시다   "부모의 생성자는 물려받지 않는다!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
       은영씨 질문에 답변드리자면, 부모의 생성자는 물려받는 대상이 아니라, 호출대상이죠...자식이 태어날때 
       딱 한번 부모님의 생성자를 호출하는 거죠..
       만일 무언가 실험을 해보실 분은 super() 메서드를 원하는 시점에 해보세요
       특정 클래스의 멤버의 갯수를 말씀하실때는, 부모꺼를 말씀하시는게 아니고 해당 클래스안에 것들을 말씀하시면
       됩니다..물론 부모것을 접근을 할수 있지만요.
 
김재성씨 - 그렇죠 , .name은 인스턴스 변수이므로 오리으 ㅣ인스턴스 없이 접근하려 했으므로 에러죠
(1) (가)에서 Duck 클래스의 name 멤버변수의 값이 도날드로 바뀔 것이다.

김지언씨 - 그렇죠, 디폴트생성자인 Duck() 은 존재하지 않기 때문에 컴파일에러 나서 인스턴스 생성은 불가하죠
(2) (나) 에서 오리의 인스턴스가 1개 생성되어 heap 영역에 올라갈 것이다.

김한나씨 - X라고 하셨는데 정말 잘못된 코드가 있나요?
제가 이 문제를 일부러 낸 이유가 혼동줄려고 그랬어요, 와 쉬는 시간이네..
죄송해요 , 좀 쉬었다가 천천히 설명할께요 5시5분에 시작합니다
수업시작 하겠습니다. 이 문제는 그림으로 설명할께요~~~~~~~~~~~~~~~~~~~~

오리가 Bird를 상속받고 있으므로, 오리의 생성보다 앞서서 
Bird의 생성자를 호출하러 갑니다
오른쪽 힙영역을 보시면, 오리와 부모 둘다  name변수를
가지고 있습니다..어떻게 될까요? 
오리의 name변수가 부모인 Bird의 name변수 때문에
덮어써질까죠? 아니면 서로 상관이 없을까요? 
상관O , 무관X  정답은 그림 자체에 답이 있습니다
자식과 부모는 서로 다른 영역을 가지고 있어요~~~
그래서 서로 상관없어요, 
단지 자식인 오리가, 자기의 재산에 만족하는 것이 아니라
부모님 영역까지 침범할수 있는 욕심쟁이인거죠...
이해 되시나요? 상속관계에서는 자식은 자신의 메모리 영역
에서 만족하는게 아니라, 부모꺼까지 접근할 수 있으니
배로 늘어난거죠 재산이,..그래서 상속이라고 하고,
자식대로 내려갈수록 재산이 많아져요..
결론) 오리의 변수와 새의 변수는 서로 영향을 주지 않음 !!!

그래서 이 문항은 맞는 문항입니다 O
(3) (나)에서 에러가 나지 않는다고 가정했을 때 (다)에서 name 변수값은 도날드로 변경될 것이다.

박재헌씨 - x라고 하신거죠? 네네 답은 제대로 수행된다 입니다
(4) (라)의 문장은 제대로 수행될 것이다.


8번 문제) 
다음 설명 중 올바르지 않은 것은?
박재현씨- 그렇죠 맞습니다 O
(1) 상속이란 현실의 상,하위객체간의 관계를 OOP언어가 is a 관계로 표현한 기법이다.

배성민씨- 네 맞아요 O
(2) 상속은 extends 키워드로 구현하며, extends 키워드를 is a 로 바꾸어 이해해도 된다.

서진호씨 - 아프시다고 들었어요 네 답은 마자요 O 
(3) 상속을 이용하면, 코드를 중복정의 하지 않아도 되며 개발시 재사용이 높아진다.

손동진씨 - 맞아요 O
(4) 부모클래스의 모든 것이 자식클래스에게 물려지지만, 생성자만은 자식 클래스에게 물려지지 않는다.

신형진씨 - 오우...이거 조심해야 돼요!!!!
            ex) 철수는 마이클 조던의 아들이자, 호나우두의 아들이다..이게 가능한가요? 현실에서...
	         상속이란 현실과 같아서 부모는 오직 한객체만 둘수 있습니다...
		  class A extends 조던, 오나우두{ //이런건 용납되지 않습니다. 다중상속이라고 해요 이런걸..
		  
		  }
(5) extends 키워드는 한 클래스내에서 여러 번 사용이 가능하며, 특별히 제한은 없다. (틀리다)


문제9) 
다음 설명 중 올바르지 않은 것은?
오성규씨 - 네 맞아요
(1)자식(sub)클래스는 상속을 통하여 부모(super)클래스의 멤버 변수 및 메서드를 물려받을 수 있다.

윤빈씨 - 네 방금얘기햇듯이 서로 다른 영역입니다. 답은 틀리다X
(2)자식클래스가 보유한 변수와 메서드가 이미 부모클래스에도 동일한 명칭으로 존재할 경우, 상속을
    명시하는 자식이 보유한 변수와 메서드는 부모의 것으로 덮어써진다.

이동규씨 - 네 맞아요 O
(2) 상속을 이용하면, 객체가 일반적으로 갖는 공통성 있는 특징,기능들을 부모클래스에 정의하고, 
자식 클래스에서는 동일한 코드를 중복정의 하지 않아도 되므로, 개발시 소스의 재사용성이 높아진다.

이동열씨 - 맞아요 이건, 허용되지 않습니다 O (원칙은 그렇지만, 나중에 이걸 해결할수있습니다..참고로 알아두세요..)
(3) 현실에서도 다중 상속이 존재하지 않듯, OOP언어에서도 다중 상속은 허용되지 않는다.

이성윤씨 - 그렇죠 private 으로 선언한 데이터는 해당 클래스 자신의 멤버들끼리만 접근할 수 있어요.. 
답은 틀리다 X
(4) 부모클래스에서 멤버변수에 private 으로 접근 제한을 둘 경우, 이 멤버변수 조차도 자식이 접근할 수 있다.

이어진씨 - 어렵죠..이 설명에서 의도하는 바가 결국 부모생성자가 상속되지 않는다 이므로 맞다고 하시면 됩니당
(5) 부모의 생성자가 상속되지 않는 이유는 생성자의 목적이 해당 객체가 태어날 때 그 객체만이 갖는 개성과
   스타일 등 해당 객체만이 가질 수 있는 유일한 초기화 작업을 지원하기 위함이므로, 생성자를 자식객체가 
물려받는다 하더라도, 사용할 의미가 없다고 보아야한다.

두 문제 남았으니 얼릉 끝내죠~~


문제10) 같이 풀어봅시다

아래 클래스에 대한 설명 중 맞는 것을 모두 고르면?
class Bird{
   String name=”새”;
   boolean fly;
   public Bird(Boolean f){ //매개변수 있는 생성자만 존재하므로, 디폴트 생성자는 없습니다 ㅎㅎ
       fly=f;
}
}
class Duck extends Bird{
    String sound=”quack”;
    //눈에 보이지 않는 생성자인 디폴트 생성자가 숨어있고, 그 안에는 super() 디폴트 부모 생성자를호출하고 있을거에요
    public Duck(){
	super(); //하지만, 부모에는 디폴트 생성자가 없으니...존재하지 않는 생성자를 호출하고 있으니 에러가 나겟죠?
	//바로 위에서  super() 에서만 부모의 생성자를 호출할수 있고, 그 외에서는 호출불가입니당!!
	왜?? 자식이 태어나기 전에 부모가 태어나야 하므로, 이 순간은 윗라인 이외밖에 없거든요~!~~~~
    }
}
class  UseTest{
public static void main(String[] args){
        Bird b=new Bird(); (가) 
        b.sound=”JJack JJack”; (나) 
        Duck d=new Duck(); (다)
}
}

임현주씨 - 틀리다입니다 X매개변수 있는 생성자만 존재하므로, 디폴트 생성자는 없습니다
(1) (가)는 Bird 클래스를 메모리에 올리는 과정이므로 아무런 문제가 없다.

장형규씨 - 
// sound변수는 부모에게 없습니다...자식에게만있습니다.
//부모는 자식것을 접근하지 못합니다..상속의 목적은 자식이 부모껏을 물려받는데 있으니까요~
따라서 답은 틀리다 입니다
(2) (나)의 코드는 문제가 없이 실행될 것이다.

전재우씨 - 그렇죠 에러납니다..ㅈ잘하셧어요
(3) (다)의 코드는 Duck 클래스를 메모리에 올리는 과정이므로 아무런 문제가 없다.

조혜씨 - 맞아요~~
(4) 자식클래스는 부모클래스의 name,fly 변수를 상속받는다.

최시민씨 - 자식은 부모의 생성자를 상속받지 않습니다. X
 만일 상속받은 메서드라면, 언제나 자식이 필요할때 호출해야 하는데, 부모의 생성자 호출은 마우때나 할수있는게
 아니라 오직 자식의 생성자 내에서 최최에 한번만 할수 있어요 그 위치는 바로 자식 생성자 첫줄입니다..
 그 외에서는 호출하지 못해요..그래서 물려받지 않는다고 생각해야 합니당!!!

(5) 자식클래스는 부모클래스의 생성자를 상속받는다. X

최은영씨 - 네 맞습니다
(6) 현실과 마찬가지로, 자식보다 부모의 존재가 시점상 우선해야 하므로, 상속 관계에 있는 자식 클래스를 
메모리에 올리는 순간, 부모클래스의 인스턴스화 작업이 먼저 선행되어져야 한다.


11번 오늘의 마지막 문제)
최준혁씨가 멋지게 마물해주세용~

잘하셧어요 아주!!!
현실에 존재하는 여러 사물들은 단독적이기보다 서로 관계를 맺고 존재하는 경우가 대부분이다.
특히 OOP언어가 주목하고 있는 객체간의 관계는 2가지가 있는데, 하나는 객체간의 상,하위 관계를 
(  is a  )관계로 보고 (       extends  )키워드로 구현한다. 
또 다른 하나는 객체가 특정 객체들을 부품으로 보유하는 관계를 (   has a   )보고, 객체자료형을 
(  멤버변수  )로 보유하여 구현한다.

오늘 여기까지 한거 공유해드릴께요, 파일로 
깃헙에 올리기도 할거구요 
1000줄이 넘어갓어요
손이 붓네요 ㅎㅎㅎ

김용(9994)님이 모두에게:  05:43 PM
강사님 혹시 만약에 Taxi에서 부모인 Car의 변수값을 바꾸면 Bus에서도 바뀐 값이 적용되나요??
아닙니다~~~
왜냐면, 인스턴스가 바뀐것이라서 클래스 원본이 바뀐게 아니에요
static을 부모가 가지고 잇고, 이것을 공유하면 다같이 바뀌겟지만, new Taxi(), new Bus() 
각각 Car 인스턴스를 따로 따로 가지고 있는 거에요..
Taxi()+Car()  한세트,  Bus()+Car() 한세트  이해되세요??

윤빈씨 질문 
------------------------
부모{ int a = 3;}

자식 extends 부모{ int a = 5;}
메인메소드{
 자식 s = new 자식();
} 

s.a 는 5일텐데
메인 메소드안에서 부모의 int a값에 접근하는 방법은 없는건가요?
답변)  부모를 접근한다는 것은 자식의 인스턴스에서 자기와 짝을 이루는 부모 인스턴스를 접근하는 것이라서
    static 영역인 main() 메서드에서는 super나 this라는 키워드 자체를 쓸수가 없어요 

    super, this 는 오직 인스턴스 내에서 사용할수 있는 겁니다..heap 영역에서요~~
    understood? 

    50분되면 칼퇴합시당~~~~ 


























































































































































































































